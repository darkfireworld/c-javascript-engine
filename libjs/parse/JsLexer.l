%{
	#include "JsToken.h" /* Generated by bison. */
	#include "JsSys.h"
	#include <stdlib.h>
	#include <string.h>
	#include <ctype.h>
%}

%option 8bit reentrant bison-bridge
%option warn nodefault noyywrap noinput nounput
%option yylineno
%option debug
%option outfile="JsLexer.c" header-file="JsLexer.h"

%x IN_COMMENT

%%

<INITIAL>{

"&&" 			return tANDAND;
"&=" 			return tANDEQ;
"break"			return tBREAK;
"case" 			return tCASE;
"catch" 		return tCATCH;
"continue" 		return tCONTINUE;
"default" 		return tDEFAULT;
"delete" 		return tDELETE;
"/=" 			return tDIVEQ;
"do" 			return tDO;
"else" 			return tELSE;
"=="			return tEQ;
"finally" 		return tFINALLY;
"for"  			return tFOR;
"function" 		return tFUNCTION;
">=" 			return tGE;
"if" 			return tIF;
"in" 			return tIN;
"instanceof" 	return tINSTANCEOF;
"<=" 			return tLE;
"<<" 			return tLSHIFT;
"<<=" 			return tLSHIFTEQ;
"-=" 			return tMINUSEQ;
"--" 			return tMINUSMINUS;
"%=" 			return tMODEQ;
"!=" 			return tNE;
"new" 			return tNEW;
"|="		 	return tOREQ;
"||" 			return tOROR;
"+=" 			return tPLUSEQ;
"++" 			return tPLUSPLUS;
"return" 		return tRETURN;
">>" 			return tRSHIFT;
">>=" 			return tRSHIFTEQ;
"===" 			return tSEQ;
"!=="		 	return tSNE;
"*=" 			return tSTAREQ;
"switch" 		return tSWITCH;
"this" 			return tTHIS;
"throw" 		return tTHROW;
"try" 			return tTRY;
"typeof" 		return tTYPEOF;
">>>" 			return tURSHIFT;
">>>=" 			return tURSHIFTEQ;
"var" 			return tVAR;
"void"		 	return tVOID;
"while" 		return tWHILE;
"^=" 			return tXOREQ;
"true" 			return tTRUE;
"false" 		return tFALSE;
"null" 			return tNULL;
"synchronized"  return tSYNCHRONIZED;

[a-zA-Z_$][a-zA-Z_$0-9]*    {
	yylval->string = (char*)JsGcMalloc(yyleng+1,NULL,NULL);
	strcpy(yylval->string,yytext);
    return tIDENT;
}

\"([^\"]|\\\")*\"           {
	yylval->string = (char*)JsGcMalloc(yyleng-1,NULL,NULL);
	memcpy(yylval->string,yytext+1,yyleng-2);
	yylval->string[yyleng-2] = '\0';
    return tSTRING;
}

\'([^\']|\\\')*\'           {
	yylval->string = (char*)JsGcMalloc(yyleng-1,NULL,NULL);
	memcpy(yylval->string,yytext+1,yyleng-2);
	yylval->string[yyleng-2] = '\0';
    return tSTRING;
}

[0-9]+(\.[0-9]+)?(E|e(\+|-)?[0-9]*)?      {
    yylval->number = atof(yytext);
    return tNUMBER;
}


"/*"                        BEGIN(IN_COMMENT);
"//".*$                     { }
[\n]                        { return tLINETERMINATOR;}
[\r\n]                      { return tLINETERMINATOR;}
.                           { 
    if (!isspace(*yytext))
    {
        return *yytext;
    }
}

}       /* INITIAL */

<IN_COMMENT>{
"*/"            BEGIN(INITIAL);
[^*\n]+         {}
"*"             {}
\n              {}
}
%%